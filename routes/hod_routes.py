# routes/hod_routes.py
from flask import Blueprint, render_template, flash, redirect, url_for, jsonify, request
from flask_login import login_required, current_user
from functools import wraps
from extensions import db
from model import User, Department, Subject, TeacherSubject, Student, StudentPerformance, Course, AcademicYear
from datetime import datetime
import random
from utils.ai_allocator import TeacherSubjectAllocator

hod_bp = Blueprint('hod', __name__, url_prefix='/hod')

def hod_required(f):
    """Decorator to restrict access to HOD only"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role != 'hod':
            flash('Access denied. HOD privileges required.', 'danger')
            return redirect(url_for('auth.login'))
        return f(*args, **kwargs)
    return decorated_function

@hod_bp.context_processor
def utility_processor():
    """Add utility functions to template context"""
    return {
        'now': datetime.now()
    }

# =====================================================
# DASHBOARD
# =====================================================

@hod_bp.route('/dashboard')
@login_required
@hod_required
def dashboard():
    """HOD Dashboard"""
    # Get HOD's department
    department = Department.query.get(current_user.department_id)
    
    if not department:
        flash('Department not found', 'danger')
        return redirect(url_for('hod.profile'))
    
    # Get department statistics
    total_teachers = User.query.filter_by(role='teacher', department_id=department.id).count()
    total_students = Student.query.filter_by(department_id=department.id).count()
    total_subjects = Subject.query.filter_by(department_id=department.id).count()
    
    # Get teacher assignments
    teacher_assignments = db.session.query(
        TeacherSubject, User, Subject
    ).join(
        User, TeacherSubject.teacher_id == User.id
    ).join(
        Subject, TeacherSubject.subject_id == Subject.id
    ).filter(
        User.department_id == department.id,
        TeacherSubject.is_active == True
    ).limit(10).all()
    
    # Get recent student performances
    recent_performances = db.session.query(
        StudentPerformance, Student, Subject
    ).join(
        Student, StudentPerformance.student_id == Student.id
    ).join(
        Subject, StudentPerformance.subject_id == Subject.id
    ).filter(
        Student.department_id == department.id
    ).order_by(
        StudentPerformance.created_at.desc()
    ).limit(10).all()
    
    return render_template('hod/dashboard.html',
                         department=department,
                         total_teachers=total_teachers,
                         total_students=total_students,
                         total_subjects=total_subjects,
                         teacher_assignments=teacher_assignments,
                         recent_performances=recent_performances)

# =====================================================
# ASSIGN TEACHERS
# =====================================================

@hod_bp.route('/assign-teachers', methods=['GET', 'POST'])
@login_required
@hod_required
def assign_teachers():
    """Assign teachers to subjects"""
    department = Department.query.get(current_user.department_id)
    
    # Handle POST request for manual assignment
    if request.method == 'POST':
        teacher_id = request.form.get('teacher_id')
        subject_id = request.form.get('subject_id')
        semester_id = request.form.get('semester_id')
        academic_year = request.form.get('academic_year')
        
        # Get academic year object
        academic_year_obj = AcademicYear.query.filter_by(year=academic_year).first()
        
        if not academic_year_obj:
            flash('Academic year not found', 'danger')
            return redirect(url_for('hod.assign_teachers'))
        
        # Check if assignment already exists
        existing = TeacherSubject.query.filter(
            TeacherSubject.teacher_id == teacher_id,
            TeacherSubject.subject_id == subject_id,
            TeacherSubject.academic_year_id == academic_year_obj.id,
            TeacherSubject.is_active == True
        ).first()
        
        if existing:
            flash('This teacher is already assigned to this subject', 'warning')
        else:
            assignment = TeacherSubject(
                teacher_id=teacher_id,
                subject_id=subject_id,
                academic_year_id=academic_year_obj.id,
                semester_id=semester_id,
                is_active=True
            )
            db.session.add(assignment)
            db.session.commit()
            flash('Teacher assigned successfully!', 'success')
        
        return redirect(url_for('hod.assign_teachers'))
    
    # GET request - display the form
    # Get data for dropdowns
    teachers = User.query.filter_by(role='teacher', department_id=department.id).all()
    subjects = Subject.query.filter_by(department_id=department.id).all()
    semesters = db.session.query(Subject.semester_id).distinct().filter_by(department_id=department.id).all()
    
    # Get current assignments
    assignments = db.session.query(
        TeacherSubject, User, Subject
    ).join(
        User, TeacherSubject.teacher_id == User.id
    ).join(
        Subject, TeacherSubject.subject_id == Subject.id
    ).filter(
        User.department_id == department.id,
        TeacherSubject.is_active == True
    ).all()
    
    return render_template('hod/assign_teachers.html',
                         department=department,
                         teachers=teachers,
                         subjects=subjects,
                         semesters=semesters,
                         assignments=assignments)

# =====================================================
# REMOVE ASSIGNMENT
# =====================================================

@hod_bp.route('/remove-assignment/<int:assignment_id>')
@login_required
@hod_required
def remove_assignment(assignment_id):
    """Remove teacher assignment"""
    assignment = TeacherSubject.query.get_or_404(assignment_id)
    assignment.is_active = False
    db.session.commit()
    flash('Assignment removed successfully!', 'success')
    return redirect(url_for('hod.assign_teachers'))

# =====================================================
# AI ASSIGN TEACHERS - FIXED VERSION
# =====================================================

@hod_bp.route('/ai-assign-teachers', methods=['POST'])
@login_required
@hod_required
def ai_assign_teachers():
    """AI-based automatic teacher assignment - Fixed saving issue"""
    department = Department.query.get(current_user.department_id)
    
    try:
        # Initialize AI allocator
        allocator = TeacherSubjectAllocator(
            department_id=department.id,
            academic_year="2025-2026"
        )
        
        # Run AI assignment
        result = allocator.assign_teachers_fast()
        
        if result['success']:
            # Save assignments to database - FIXED: Check if assignments exist and add them
            if result['assignments']:
                added_count = 0
                for assignment in result['assignments']:
                    # Check if already exists to avoid duplicates
                    existing = TeacherSubject.query.filter_by(
                        teacher_id=assignment.teacher_id,
                        subject_id=assignment.subject_id,
                        academic_year_id=assignment.academic_year_id,
                        is_active=True
                    ).first()
                    
                    if not existing:
                        db.session.add(assignment)
                        added_count += 1
                
                # Commit all changes
                db.session.commit()
                
                message = f"‚úÖ AI Assignment Complete!\n"
                message += f"   ‚Ä¢ Created {added_count} new assignments\n"
                message += f"   ‚Ä¢ Total subjects in even semesters: {result.get('total_assigned', 0)}\n"
                
                # Add teacher distribution
                if 'teacher_distribution' in result:
                    message += f"\n   üìä Teacher Workload:\n"
                    for teacher, count in result['teacher_distribution'].items():
                        message += f"      - {teacher}: {count}/5 subjects\n"
                
                if result.get('failed_subjects'):
                    message += f"\n   ‚ö†Ô∏è Failed to assign: {len(result['failed_subjects'])} subjects"
                
                flash(message, 'success')
            else:
                flash('No new assignments were created', 'warning')
        else:
            flash(f"‚ùå {result['message']}", 'danger')
            
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Error in AI assignment: {str(e)}', 'danger')
        print(f"AI Assignment Error: {str(e)}")  # For debugging
        
    return redirect(url_for('hod.assign_teachers'))
# =====================================================
# RESET ASSIGNMENTS - FIXED VERSION
# =====================================================

@hod_bp.route('/reset-assignments', methods=['POST'])
@login_required
@hod_required
def reset_assignments():
    """Reset all teacher assignments - Fixed"""
    department = Department.query.get(current_user.department_id)
    
    try:
        # Get current academic year
        academic_year = AcademicYear.query.filter_by(is_current=True).first()
        if not academic_year:
            flash('No current academic year found', 'danger')
            return redirect(url_for('hod.assign_teachers'))
        
        # Count assignments before reset
        count_before = TeacherSubject.query.filter_by(
            academic_year_id=academic_year.id,
            is_active=True
        ).count()
        
        # Soft delete - set is_active to False
        result = TeacherSubject.query.filter_by(
            academic_year_id=academic_year.id,
            is_active=True
        ).update({'is_active': False}, synchronize_session=False)
        
        db.session.commit()
        
        flash(f'‚úÖ Reset {result} teacher assignments successfully!', 'success')
        print(f"Reset {result} assignments")  # For debugging
        
    except Exception as e:
        db.session.rollback()
        flash(f'‚ùå Error resetting assignments: {str(e)}', 'danger')
        print(f"Reset Error: {str(e)}")  # For debugging
        
    return redirect(url_for('hod.assign_teachers'))

# =====================================================
# ASSIGNMENT STATS API
# =====================================================

@hod_bp.route('/assignment-stats')
@login_required
@hod_required
def assignment_stats():
    """Get assignment statistics as JSON - Fast version"""
    department = Department.query.get(current_user.department_id)
    
    allocator = TeacherSubjectAllocator(department_id=department.id)
    stats = allocator.get_assignment_stats_fast()
    
    return jsonify(stats)

# =====================================================
# TEACHER DETAILS
# =====================================================

@hod_bp.route('/teacher-details')
@login_required
@hod_required
def teacher_details():
    """View all teachers in department"""
    department = Department.query.get(current_user.department_id)
    teachers = User.query.filter_by(role='teacher', department_id=department.id).all()
    
    # Get subject counts and names for each teacher
    teacher_data = []
    for teacher in teachers:
        # Get all active assignments for this teacher
        assignments = TeacherSubject.query.filter(
            TeacherSubject.teacher_id == teacher.id,
            TeacherSubject.is_active == True
        ).all()
        
        # Get subject names
        subject_names = []
        for assignment in assignments:
            subject = Subject.query.get(assignment.subject_id)
            if subject:
                subject_names.append(subject.name)
        
        teacher_data.append({
            'teacher': teacher,
            'subject_count': len(assignments),
            'subject_names': subject_names
        })
    
    return render_template('hod/teacher_details.html',
                         department=department,
                         teacher_data=teacher_data)
   
    
@hod_bp.route('/teacher-profile/<int:teacher_id>')
@login_required
@hod_required
def teacher_profile(teacher_id):
    """View individual teacher profile"""
    teacher = User.query.get_or_404(teacher_id)
    
    if teacher.department_id != current_user.department_id:
        flash('Access denied', 'danger')
        return redirect(url_for('hod.teacher_details'))
    
    # Get teacher's subjects
    subjects = db.session.query(
        TeacherSubject, Subject
    ).join(
        Subject, TeacherSubject.subject_id == Subject.id
    ).filter(
        TeacherSubject.teacher_id == teacher.id,
        TeacherSubject.is_active == True
    ).all()
    
    return render_template('hod/teacher_profile.html',
                         teacher=teacher,
                         subjects=subjects)



# =====================================================
# PERFORMANCE ANALYSIS
# =====================================================

@hod_bp.route('/performance-analysis')
@login_required
@hod_required
def performance_analysis():
    """Subject-wise performance analysis - FIXED"""
    department = Department.query.get(current_user.department_id)
    
    # Get ALL subjects in department (including English, Maths, Physics)
    subjects = Subject.query.filter_by(department_id=department.id).order_by(Subject.semester_id, Subject.name).all()
    
    # Calculate subject-wise averages
    subject_analysis = []
    for subject in subjects:
        # Get all performances for this subject
        performances = StudentPerformance.query.filter_by(subject_id=subject.id).all()
        
        if performances:
            avg_marks = sum(p.final_internal for p in performances) / len(performances)
            avg_attendance = sum(p.attendance for p in performances) / len(performances)
            risk_count = sum(1 for p in performances if p.risk_status in ['Critical', 'High Risk'])
            student_count = len(set(p.student_id for p in performances))
        else:
            avg_marks = 0
            avg_attendance = 0
            risk_count = 0
            student_count = 0
        
        subject_analysis.append({
            'subject': subject,
            'avg_marks': round(avg_marks, 2),
            'avg_attendance': round(avg_attendance, 2),
            'total_students': student_count,
            'risk_count': risk_count,
            'performance_percent': round((avg_marks / 20 * 100) if avg_marks > 0 else 0, 1)
        })
    
    return render_template('hod/performance_analysis.html',
                         department=department,
                         subject_analysis=subject_analysis)

@hod_bp.route('/risk-levels')
@login_required
@hod_required
def risk_levels():
    """View students by risk level - Complete version with all variables"""
    department = Department.query.get(current_user.department_id)
    
    # Get filter parameters
    selected_semester = request.args.get('semester', 'all')
    selected_subject = request.args.get('subject', 'all')
    
    # Get all students in department
    students_query = Student.query.filter_by(department_id=department.id)
    
    # Apply semester filter
    if selected_semester != 'all':
        students_query = students_query.filter_by(current_semester=int(selected_semester))
    
    students = students_query.all()
    total_students = len(students)
    
    # Initialize all five categories
    critical = []
    high_risk = []
    average = []
    safe = []
    best = []
    
    # Initialize counters
    total_critical = 0
    total_high_risk = 0
    total_average = 0
    total_safe = 0
    total_best = 0
    
    # Semester-wise data
    semester_data = {}
    for sem in range(1, 9):
        semester_data[sem] = {
            'total': 0,
            'critical': 0,
            'high_risk': 0,
            'average': 0,
            'safe': 0,
            'best': 0,
            'avg_marks': 0,
            'avg_attendance': 0,
            'marks_total': 0,
            'attendance_total': 0
        }
    
    # Subject-wise risk data
    all_subjects = Subject.query.filter_by(department_id=department.id).order_by(Subject.semester_id, Subject.name).all()
    subject_risk_data = {}
    
    for subject in all_subjects:
        subject_risk_data[subject.id] = {
            'total': 0,
            'critical': 0,
            'high_risk': 0,
            'average': 0,
            'safe': 0,
            'best': 0,
            'avg_marks': 0,
            'avg_attendance': 0,
            'marks_total': 0,
            'attendance_total': 0
        }
    
    for student in students:
        # Get performances - optionally filter by subject
        performances_query = StudentPerformance.query.filter_by(student_id=student.id)
        
        if selected_subject != 'all':
            performances_query = performances_query.filter_by(subject_id=int(selected_subject))
        
        performances = performances_query.all()
        
        if performances:
            # Get the most recent performance
            latest = performances[-1]
            subject = Subject.query.get(latest.subject_id)
            
            if not subject or subject.department_id != department.id:
                continue
            
            # Get data
            marks = latest.final_internal
            attendance = latest.attendance
            
            # Calculate grade
            if marks >= 18:
                grade = 'A+'
            elif marks >= 15:
                grade = 'A'
            elif marks >= 12:
                grade = 'B'
            elif marks >= 10:
                grade = 'C'
            else:
                grade = 'D'
            
            student_data = {
                'student': student,
                'subject': subject.name if subject else 'Unknown',
                'subject_id': subject.id if subject else None,
                'marks': marks,
                'attendance': attendance,
                'grade': grade,
                'semester': student.current_semester
            }
            
            # Categorize based on risk_status from database
            risk_status = latest.risk_status
            
            # Update counters
            if risk_status == 'Critical':
                critical.append(student_data)
                total_critical += 1
            elif risk_status == 'High Risk':
                high_risk.append(student_data)
                total_high_risk += 1
            elif risk_status == 'Average':
                average.append(student_data)
                total_average += 1
            elif risk_status == 'Best':
                best.append(student_data)
                total_best += 1
            else:  # Safe or any other
                safe.append(student_data)
                total_safe += 1
            
            # Update semester data
            sem = student.current_semester
            if sem in semester_data:
                semester_data[sem]['total'] += 1
                semester_data[sem][risk_status.lower().replace(' ', '_')] += 1
                semester_data[sem]['marks_total'] += marks
                semester_data[sem]['attendance_total'] += attendance
            
            # Update subject data
            if subject and subject.id in subject_risk_data:
                subject_risk_data[subject.id]['total'] += 1
                subject_risk_data[subject.id][risk_status.lower().replace(' ', '_')] += 1
                subject_risk_data[subject.id]['marks_total'] += marks
                subject_risk_data[subject.id]['attendance_total'] += attendance
    
    # Calculate averages for semester data
    for sem, data in semester_data.items():
        if data['total'] > 0:
            data['avg_marks'] = data['marks_total'] / data['total']
            data['avg_attendance'] = data['attendance_total'] / data['total']
    
    # Calculate averages for subject data
    for subject_id, data in subject_risk_data.items():
        if data['total'] > 0:
            data['avg_marks'] = data['marks_total'] / data['total']
            data['avg_attendance'] = data['attendance_total'] / data['total']
    
    # Get unique semesters for filter dropdown
    semesters = db.session.query(Student.current_semester).distinct().filter_by(
        department_id=department.id
    ).order_by(Student.current_semester).all()
    semesters = [s[0] for s in semesters]
    
    return render_template('hod/risk_levels.html',
                         department=department,
                         critical=critical,
                         high_risk=high_risk,
                         average=average,
                         safe=safe,
                         best=best,
                         total_critical=total_critical,
                         total_high_risk=total_high_risk,
                         total_average=total_average,
                         total_safe=total_safe,
                         total_best=total_best,
                         total_students=total_students,
                         semesters=semesters,
                         all_subjects=all_subjects,
                         subject_risk_data=subject_risk_data,
                         semester_data=semester_data,
                         selected_semester=selected_semester,
                         selected_subject=selected_subject)
# =====================================================
# PROFILE
# =====================================================

# In hod_routes.py, update the profile route:

@hod_bp.route('/profile')
@login_required
@hod_required
def profile():
    """HOD Profile Page - FIXED with all required data"""
    department = Department.query.get(current_user.department_id)
    
    if not department:
        flash('Department not found', 'danger')
        return redirect(url_for('hod.dashboard'))
    
    # Get counts for department statistics
    teacher_count = User.query.filter_by(role='teacher', department_id=department.id).count()
    student_count = Student.query.filter_by(department_id=department.id).count()
    subject_count = Subject.query.filter_by(department_id=department.id).count()
    
    # Get performance statistics
    performances = StudentPerformance.query.join(Student).filter(
        Student.department_id == department.id
    ).all()
    
    if performances:
        total_marks = sum(p.final_internal for p in performances)
        avg_marks = total_marks / len(performances)
        pass_count = sum(1 for p in performances if p.final_internal >= 10)
        pass_rate = (pass_count / len(performances)) * 100 if performances else 0
        
        # Calculate attendance average
        total_attendance = sum(p.attendance for p in performances)
        avg_attendance = total_attendance / len(performances) if performances else 0
    else:
        avg_marks = 0
        pass_rate = 0
        avg_attendance = 0
    
    return render_template('hod/profile.html',
                         department=department,
                         teacher_count=teacher_count,
                         student_count=student_count,
                         subject_count=subject_count,
                         avg_marks=round(avg_marks, 1),
                         pass_rate=round(pass_rate, 1),
                         avg_attendance=round(avg_attendance, 1))

# =====================================================
# API ENDPOINTS FOR CHARTS
# =====================================================

@hod_bp.route('/api/chart-data')
@login_required
@hod_required
def chart_data():
    """API endpoint to provide chart data"""
    department_id = current_user.department_id
    
    # Subject-wise average marks
    subjects = Subject.query.filter_by(department_id=department_id).all()
    subject_names = []
    subject_avg = []
    
    for subject in subjects[:10]:  # Limit to 10 subjects
        performances = StudentPerformance.query.filter_by(subject_id=subject.id).all()
        if performances:
            avg = sum(p.final_internal for p in performances) / len(performances)
            subject_names.append(subject.name[:15] + '...' if len(subject.name) > 15 else subject.name)
            subject_avg.append(round(avg, 2))
    
    # Risk distribution
    students = Student.query.filter_by(department_id=department_id).all()
    risk_counts = {'Critical': 0, 'High Risk': 0, 'Average': 0, 'Safe': 0}
    
    for student in students:
        performances = StudentPerformance.query.filter_by(student_id=student.id).all()
        if performances:
            latest = performances[-1]
            if latest.risk_status in risk_counts:
                risk_counts[latest.risk_status] += 1
    
    return jsonify({
        'subject_names': subject_names,
        'subject_avg': subject_avg,
        'risk_labels': list(risk_counts.keys()),
        'risk_data': list(risk_counts.values())
    })
    # Add to hod_routes.py - Ultra Fast AI Assignment

@hod_bp.route('/ultra-fast-assign', methods=['POST'])
@login_required
@hod_required
def ultra_fast_assign():
    """Ultra fast AI assignment - completes instantly"""
    department = Department.query.get(current_user.department_id)
    
    from utils.ultra_fast_allocator import UltraFastAllocator
    allocator = UltraFastAllocator(department_id=department.id)
    result = allocator.assign_now()
    
    if result['success']:
        flash(f'‚úì Assigned {result["assigned"]} subjects instantly!', 'success')
    else:
        flash(f'Error: {result["message"]}', 'danger')
    
    return redirect(url_for('hod.assign_teachers'))

@hod_bp.route('/debug-assignments')
@login_required
@hod_required
def debug_assignments():
    """Debug route to check assignments in database"""
    department = Department.query.get(current_user.department_id)
    academic_year = AcademicYear.query.filter_by(is_current=True).first()
    
    if not academic_year:
        return "No academic year found"
    
    # Get all assignments
    assignments = TeacherSubject.query.filter_by(
        academic_year_id=academic_year.id,
        is_active=True
    ).all()
    
    html = f"""
    <h2>Assignments in Database</h2>
    <p>Department: {department.name}</p>
    <p>Total Assignments: {len(assignments)}</p>
    <table border='1' cellpadding='5'>
        <tr>
            <th>ID</th>
            <th>Teacher ID</th>
            <th>Subject ID</th>
            <th>Semester</th>
            <th>Active</th>
        </tr>
    """
    
    for a in assignments:
        teacher = User.query.get(a.teacher_id)
        subject = Subject.query.get(a.subject_id)
        html += f"""
        <tr>
            <td>{a.id}</td>
            <td>{teacher.full_name if teacher else a.teacher_id}</td>
            <td>{subject.name if subject else a.subject_id}</td>
            <td>{a.semester_id}</td>
            <td>{a.is_active}</td>
        </tr>
        """
    
    html += "</table>"
    html += '<br><a href="/hod/assign-teachers">Back to Assign Teachers</a>'
    
    return html
@hod_bp.route('/student-performance')
@login_required
@hod_required
def student_performance():
    """View student performances filtered by teacher assignments"""
    department = Department.query.get(current_user.department_id)
    
    # Get filter parameters
    teacher_id = request.args.get('teacher_id', 'all')
    semester = request.args.get('semester', 'all')
    risk_level = request.args.get('risk', 'all')
    search = request.args.get('search', '')
    
    # Get all teachers in department with proper names
    teachers = User.query.filter_by(role='teacher', department_id=department.id).all()
    
    # Format teacher names properly
    for teacher in teachers:
        if not teacher.full_name:
            # If no full_name, use username or email to create a proper name
            if teacher.username:
                # Convert username like "john.doe" to "John Doe"
                name_parts = teacher.username.replace('.', ' ').split()
                teacher.display_name = ' '.join([part.capitalize() for part in name_parts])
            elif teacher.email:
                # Use email username part
                name_parts = teacher.email.split('@')[0].replace('.', ' ').split()
                teacher.display_name = ' '.join([part.capitalize() for part in name_parts])
            else:
                teacher.display_name = f"Teacher {teacher.id}"
        else:
            teacher.display_name = teacher.full_name
    
    # Base query for students
    students_query = Student.query.filter_by(department_id=department.id)
    
    # Apply semester filter
    if semester != 'all' and semester:
        students_query = students_query.filter_by(current_semester=int(semester))
    
    # Apply search filter
    if search:
        students_query = students_query.filter(
            db.or_(
                Student.name.ilike(f'%{search}%'),
                Student.registration_number.ilike(f'%{search}%')
            )
        )
    
    students = students_query.all()
    
    # Get all teacher-subject assignments with teacher details
    teacher_assignments = db.session.query(
        TeacherSubject, User, Subject
    ).join(
        User, TeacherSubject.teacher_id == User.id
    ).join(
        Subject, TeacherSubject.subject_id == Subject.id
    ).filter(
        User.department_id == department.id,
        TeacherSubject.is_active == True
    ).all()
    
    # Create mapping of subject_id to teacher with proper names
    subject_teacher_map = {}
    teacher_info_cache = {}
    
    for assignment, teacher, subject in teacher_assignments:
        # Get or create teacher display name
        if teacher.id not in teacher_info_cache:
            if teacher.full_name:
                display_name = teacher.full_name
            elif teacher.username:
                # Clean up username
                name = teacher.username.replace('_', ' ').replace('.', ' ')
                display_name = ' '.join([part.capitalize() for part in name.split()])
            else:
                display_name = f"Teacher {teacher.id}"
            teacher_info_cache[teacher.id] = {
                'id': teacher.id,
                'name': display_name,
                'username': teacher.username,
                'email': teacher.email
            }
        
        subject_teacher_map[subject.id] = teacher_info_cache[teacher.id]
    
    # Get performance data with teacher info
    performance_data = []
    
    # Stats tracking with proper teacher names
    teacher_stats = {}
    for teacher in teachers:
        teacher_stats[teacher.id] = {
            'name': teacher_info_cache.get(teacher.id, {}).get('name', teacher.full_name or f"Teacher {teacher.id}"),
            'critical': 0,
            'total': 0,
            'high_risk': 0,
            'average': 0,
            'safe': 0
        }
    
    teacher_stats['unassigned'] = {
        'name': 'Unassigned Students',
        'critical': 0,
        'total': 0,
        'high_risk': 0,
        'average': 0,
        'safe': 0
    }
    
    for student in students:
        # Get all performances for this student
        performances = db.session.query(
            StudentPerformance, Subject
        ).join(
            Subject, StudentPerformance.subject_id == Subject.id
        ).filter(
            StudentPerformance.student_id == student.id
        ).all()
        
        # Track which teachers this student is associated with
        student_teachers = set()
        teacher_names = []
        
        if performances:
            # Calculate averages
            marks_list = [p.final_internal for p, _ in performances]
            avg_marks = sum(marks_list) / len(marks_list)
            
            # Get latest risk status
            latest_perf = max(performances, key=lambda x: x[0].created_at)[0]
            risk_status = latest_perf.risk_status
            
            # Get subject-wise breakdown with teacher info
            subjects_data = []
            for perf, subject in performances:
                teacher_info = subject_teacher_map.get(subject.id, {})
                if teacher_info:
                    student_teachers.add(teacher_info['id'])
                    teacher_names.append({
                        'id': teacher_info['id'],
                        'name': teacher_info['name']
                    })
                
                subjects_data.append({
                    'subject_name': subject.name,
                    'marks': perf.final_internal,
                    'risk': perf.risk_status,
                    'teacher_id': teacher_info.get('id'),
                    'teacher_name': teacher_info.get('name', 'Not Assigned')
                })
        else:
            avg_marks = 0
            risk_status = 'No Data'
            subjects_data = []
        
        # Remove duplicate teachers
        unique_teachers = {}
        for t in teacher_names:
            if t['id'] not in unique_teachers:
                unique_teachers[t['id']] = t['name']
        
        teacher_list = [{'id': tid, 'name': name} for tid, name in unique_teachers.items()]
        
        # Update teacher stats
        if teacher_list:
            for t in teacher_list:
                if t['id'] in teacher_stats:
                    teacher_stats[t['id']]['total'] += 1
                    if risk_status == 'Critical':
                        teacher_stats[t['id']]['critical'] += 1
                    elif risk_status == 'High Risk':
                        teacher_stats[t['id']]['high_risk'] += 1
                    elif risk_status == 'Average':
                        teacher_stats[t['id']]['average'] += 1
                    elif risk_status == 'Safe':
                        teacher_stats[t['id']]['safe'] += 1
        else:
            teacher_stats['unassigned']['total'] += 1
            if risk_status == 'Critical':
                teacher_stats['unassigned']['critical'] += 1
            elif risk_status == 'High Risk':
                teacher_stats['unassigned']['high_risk'] += 1
            elif risk_status == 'Average':
                teacher_stats['unassigned']['average'] += 1
            elif risk_status == 'Safe':
                teacher_stats['unassigned']['safe'] += 1
        
        # Apply teacher filter
        if teacher_id != 'all':
            if teacher_id == 'unassigned':
                if teacher_list:  # Has teachers, so skip
                    continue
            else:
                teacher_id_int = int(teacher_id) if teacher_id.isdigit() else None
                teacher_ids = [t['id'] for t in teacher_list]
                if teacher_id_int not in teacher_ids:
                    continue
        
        # Apply risk filter
        if risk_level != 'all' and risk_status != risk_level:
            continue
        
        performance_data.append({
            'student': student,
            'avg_marks': round(avg_marks, 2),
            'risk_status': risk_status,
            'subject_count': len(performances),
            'subjects': subjects_data,
            'has_data': len(performances) > 0,
            'teachers': teacher_list,
            'teacher_count': len(teacher_list)
        })
    
    # Calculate critical percentage for each teacher
    for t_id, stats in teacher_stats.items():
        if stats['total'] > 0:
            stats['critical_percent'] = round((stats['critical'] / stats['total']) * 100, 1)
        else:
            stats['critical_percent'] = 0
    
    # Get unique semesters for filter
    available_semesters = db.session.query(Student.current_semester).distinct().filter_by(
        department_id=department.id
    ).order_by(Student.current_semester).all()
    
    # Calculate summary stats
    total_critical = sum(1 for item in performance_data if item['risk_status'] == 'Critical')
    total_students = len(performance_data)
    
    return render_template('hod/student_performance.html',
                         department=department,
                         teachers=teachers,
                         teacher_stats=teacher_stats,
                         performance_data=performance_data,
                         available_semesters=[s[0] for s in available_semesters],
                         total_critical=total_critical,
                         total_students=total_students,
                         current_filters={
                             'teacher_id': teacher_id,
                             'semester': semester,
                             'risk': risk_level,
                             'search': search
                         })
    
@hod_bp.route('/student-detail/<int:student_id>')
@login_required
@hod_required
def student_detail(student_id):
    """View individual student performance"""
    student = Student.query.get_or_404(student_id)
    
    if student.department_id != current_user.department_id:
        flash('Access denied', 'danger')
        return redirect(url_for('hod.student_performance'))
    
    # Get all performances for this student
    performances = db.session.query(
        StudentPerformance, Subject
    ).join(
        Subject, StudentPerformance.subject_id == Subject.id
    ).filter(
        StudentPerformance.student_id == student.id
    ).all()
    
    return render_template('hod/student_detail.html',
                         student=student,
                         performances=performances)
    
@hod_bp.route('/debug-hod-endpoints')
@login_required
@hod_required
def debug_hod_endpoints():
    """List all HOD endpoints"""
    from flask import current_app
    endpoints = []
    for rule in current_app.url_map.iter_rules():
        if 'hod.' in rule.endpoint:
            endpoints.append(f"{rule.endpoint} -> {rule}")
    return "<br>".join(sorted(endpoints))


@hod_bp.route('/debug-teacher-assignments')
@login_required
@hod_required
def debug_teacher_assignments():
    """Debug teacher assignments"""
    department = Department.query.get(current_user.department_id)
    
    # Check academic year
    academic_year = AcademicYear.query.filter_by(is_current=True).first()
    if not academic_year:
        # Create academic year if not exists
        from datetime import date
        academic_year = AcademicYear(
            year="2025-2026",
            is_current=True,
            start_date=date(2025, 6, 1),
            end_date=date(2026, 4, 30)
        )
        db.session.add(academic_year)
        db.session.commit()
    
    # Get all assignments
    assignments = TeacherSubject.query.filter_by(
        academic_year_id=academic_year.id,
        is_active=True
    ).all()
    
    html = f"""
    <h2>Teacher Assignments Debug</h2>
    <p>Department: {department.name}</p>
    <p>Academic Year: {academic_year.year} (ID: {academic_year.id})</p>
    <p>Total Assignments: {len(assignments)}</p>
    
    <h3>Teachers ({User.query.filter_by(role='teacher', department_id=department.id).count()})</h3>
    <table border='1' cellpadding='5'>
        <tr><th>ID</th><th>Name</th><th>Username</th></tr>
    """
    for teacher in User.query.filter_by(role='teacher', department_id=department.id).all():
        html += f"<tr><td>{teacher.id}</td><td>{teacher.full_name}</td><td>{teacher.username}</td></tr>"
    
    html += f"""
    </table>
    
    <h3>Subjects ({Subject.query.filter_by(department_id=department.id).count()})</h3>
    <table border='1' cellpadding='5'>
        <tr><th>ID</th><th>Name</th><th>Code</th><th>Semester</th></tr>
    """
    for subject in Subject.query.filter_by(department_id=department.id).all():
        html += f"<tr><td>{subject.id}</td><td>{subject.name}</td><td>{subject.code}</td><td>{subject.semester_id}</td></tr>"
    
    html += f"""
    </table>
    
    <h3>Current Assignments</h3>
    <table border='1' cellpadding='5'>
        <tr><th>ID</th><th>Teacher</th><th>Subject</th><th>Semester</th><th>Active</th></tr>
    """
    for a in assignments:
        teacher = User.query.get(a.teacher_id)
        subject = Subject.query.get(a.subject_id)
        html += f"<tr><td>{a.id}</td><td>{teacher.full_name if teacher else 'Unknown'}</td><td>{subject.name if subject else 'Unknown'}</td><td>{a.semester_id}</td><td>{a.is_active}</td></tr>"
    
    html += "</table>"
    html += '<br><a href="/hod/assign-teachers">Back to Assign Teachers</a>'
    
    return html